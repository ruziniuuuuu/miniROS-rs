# miniROS-rs Project Rules

## Core Principles

- **Focus on ROS Core Functionality**: Implement only essential ROS2-like features (pub/sub, services, parameters, actions, visualization)
- **Simplicity Over Complexity**: Keep examples and implementations minimal and focused
- **ROS2 Compatibility**: Python API should mimic ROS2 rclpy style for easy migration
- **Cross-language Integration**: Rust core with Python bindings via PyO3

## Code Style & Quality

### Comments and Documentation
- **ALL comments and documentation MUST be in English**
- Use clear, concise explanations
- Document public APIs thoroughly
- Include usage examples in documentation

### Rust Code Standards
- Fix ALL compiler warnings before committing
- Use `#[allow(dead_code)]` with explanatory comments for future-reserved fields
- Prefer explicit error handling over panics
- Keep examples under 200 lines when possible
- Use descriptive variable and function names

### Python Code Standards
- Follow ROS2 rclpy API conventions exactly
- Keep examples minimal and tutorial-like
- Use functional style over class-based when simpler
- Each example should demonstrate one core concept
- Maximum file size for examples: ~1KB for minimal, ~2KB for comprehensive

## Architecture Requirements

### Rust Implementation
- Core functionality in Rust for performance
- Use feature flags for optional components
- Async/await for I/O operations
- Thread-safe designs with Arc<Mutex<T>> when needed

### Python Bindings
- PyO3 for Rust-Python integration
- Mirror ROS2 rclpy API structure:
  ```python
  import mini_ros
  mini_ros.init()
  node = mini_ros.Node('name')
  pub = node.create_publisher(mini_ros.StringMessage, 'topic', 10)
  sub = node.create_subscription(mini_ros.StringMessage, 'topic', callback, 10)
  mini_ros.spin(node)
  node.destroy_node()
  mini_ros.shutdown()
  ```

## Examples Guidelines

### Rust Examples
- Focus on single functionality per example
- Use clear step-by-step structure
- Include comprehensive logging
- Handle errors gracefully
- Examples naming: `01_basic_pubsub.rs`, `02_custom_messages.rs`, etc.

### Python Examples
- Keep it simple and educational
- Must actually call Rust APIs (not mock implementations)
- Provide minimal and comprehensive versions
- Examples should be runnable immediately
- Required examples:
  - `minimal_publisher.py` / `minimal_subscriber.py` (< 30 lines each)
  - `talker.py` / `listener.py` (with logging)
  - `simple_pubsub.py` (combined demo)
  - `simple_param.py` (parameter usage)

## File Organization

```
├── src/
│   ├── lib.rs          # Main library exports
│   ├── core.rs         # Context and initialization
│   ├── node.rs         # Node implementation
│   ├── publisher.rs    # Publisher functionality
│   ├── subscriber.rs   # Subscriber functionality
│   ├── service.rs      # Service implementation
│   ├── action.rs       # Action implementation
│   ├── parameter.rs    # Parameter system
│   ├── visualization.rs # Rerun integration
│   └── python.rs       # Python bindings
├── examples/           # Rust examples (numbered)
├── python/
│   └── examples/       # Python examples (descriptive names)
└── tests/              # Unit and integration tests
```

## Commit Standards

### Commit Messages
- Use conventional commits format
- Keep messages concise but descriptive
- Examples:
  - `fix: resolve warnings in examples 05-07`
  - `feat: add visualization types to python API`
  - `refactor: simplify python examples to ROS2 style`

### What to Commit
- All warnings and errors must be fixed before commit
- Examples must be tested and working
- Python examples must follow ROS2 patterns
- Documentation must be updated with API changes

## Dependencies

### Rust Dependencies
- Keep dependencies minimal and well-justified
- Prefer std library when possible
- Use tokio for async runtime
- Use serde for serialization
- Use PyO3 for Python bindings
- Use rerun for visualization (optional feature)

### Python Dependencies
- Minimize external dependencies
- Standard library preferred for examples
- Only add dependencies that provide significant value

## Testing Requirements

- Unit tests for all core functionality
- Integration tests for cross-language features
- Examples should serve as integration tests
- All tests must pass before merging
- Test both Rust and Python APIs

## Performance Considerations

- Rust core for performance-critical paths
- Minimize allocations in hot paths
- Use zero-copy where possible
- Profile and optimize bottlenecks
- Async for I/O, sync for CPU-bound work

## Error Handling

- Use Result<T, E> pattern in Rust
- Provide meaningful error messages
- Handle network failures gracefully
- Log errors at appropriate levels
- Python exceptions should map to Rust errors

## Documentation Standards

- README files for each major component
- API documentation for all public interfaces
- Examples with explanatory comments
- Architecture decisions documented
- Getting started guide for users

## Version Compatibility

- Follow semantic versioning
- Maintain API backward compatibility
- Document breaking changes clearly
- Provide migration guides for major versions
- Support Python 3.8+ for broad compatibility 